Pixels and colours - playing with HTML5 Canvas

When people talk about HTML5 Canvas the topic revolves most of the time about painting on the screen and its painting API. The next topic is most likely performance and hardware acceleration and the benefits of using one game creation library or the other as Canvas is just too hard and buggy and confusing amongst many other things. It reminds me of people starting to play with the DOM, running into some trouble and getting advised to use jQuery instead. 

Today I want to show you that not Canvas is more than a very rudimentary painting API but first and foremost there to manipulate pixels which makes it very easy to reach impressive results. 

First things first though: if you want to create a full-on game, you probably want to re-use the knowledge and flexibility that libraries give you. I am not claiming that they are not necessary or useful, but it is important to understand the nuts and bolts, too. Much like a good dish starts with high quality ingredients the joy of developing should start with knowing what you are doing under the hood. 

I got the inspiration for this standing on a platform and waiting for a train. 
Opposite were lots of posters advertising things I don't need or want and one of them was an ad for a tablet. This one showed an app for kids to paint along letters. I thought that can be done in plain and simple HTML5 instead of native code and had a go at it. The result is an HTML5 app I created to use in my Firefox OS workshops called letterpaint.

Before writing any code, I thought how this effect could be done. I needed to find solutions for the following:

<ul><li>Allow the player to paint on the screen</li>
<li>Ensure that the player stays within the boundaries of a shape (in this case a letter)</li>
<li>Find out when the letter was painted out enough to be able to say the player managed to trace it</li></ul>

<h2>Painting on a canvas</h2>

Allowing the user to paint on a canvas is very easy: 

<ul><li>Get a Canvas' context</li><li>Read the mouse position on the Canvas</li><li>Move to the position on the Canvas</li><li>Paint a line</li></ul>

Here's all the code that is needed for that to happen: 

<pre>var c = document.querySelector('canvas');
var cx = c.getContext('2d');
var mousedown = false;

function setupCanvas() {
  c.height = 480;
  c.width = 320;
  cx.lineWidth = 20;
  cx.lineCap = 'round';
  cx.strokeStyle = 'rgb(0, 0, 50)';
}
function onmousemove(ev) {
  var x = ev.clientX;
  var y = ev.clientY;
  paint(x, y);
}
function paint(x, y) {
  cx.beginPath();
  cx.moveTo(x, y);
  cx.lineTo(x, y);
  cx.stroke();
  cx.closePath();
}
c.addEventListener('mousemove', onmousemove, false);

setupCanvas();</pre>

If you <a href="01-paint.html">try this out</a>, you'll see that you paint on the canvas as soon as you move the mouse over it. That is not what we want though. We only want to paint when the mouse button is down and the mouse is moved, so we need two more event listeners and a Boolean indicator for the state of the mouse. 

<pre>function onmousedown(ev) {
  mousedown = true;
  ev.preventDefault();
}
function onmouseup(ev) {
  mousedown = false;
  ev.preventDefault();
}
c.addEventListener('mousedown', onmousedown, false);
c.addEventListener('mouseup', onmouseup, false);</pre>

Now <a href="02-paint-with-mousedown.html">you only paint</a> when you move the mouse and keep the button pressed. However, there are unsightly gaps in your strokes as you can see here:

<img src="" alt="gaps in the line">

To work around this issue, we should not only move the Canvas "pen" with the mouse, but cache the last position and paint lines from the last to the new one. If we <a href="03-continuous-paint.html">do this</a> our lines are much smoother:

<img src="" alt="continuous painting">

The change is simple:

<pre>function paint(x, y) {
  cx.beginPath();
  if (oldx > 0 && oldy > 0) {
    cx.moveTo(oldx, oldy);
  }
  cx.lineTo(x, y);
  cx.stroke();
  cx.closePath();
  oldx = x;
  oldy = y;
}</pre>

Adding a letter shape to the canvas is not hard. We need to define the font, the fill style, what the text baseline is and position the text on the canvas. To center the text, we plot it at half the height of the canvas vertically and measure its width horizontally. Sounds complex, but isn't, and the code is a small addition to the <code>setupCanvas()</code> function and a new function called <code>drawletter()</code>:

<pre>function setupCanvas() {
  c.height = 480;
  c.width = 320;
  cx.lineWidth = 20;
  cx.lineCap = 'round';
  cx.strokeStyle = 'rgb(0, 0, 50)';
  cx.font = 'bold 300px helvetica';
  cx.fillStyle = 'rgb(255, 0, 0)';
  cx.textBaseline = 'middle';
  drawletter('y');
}

function drawletter(letter) {
  var centerx = (c.width - cx.measureText(letter).width) / 2;
  var centery = c.height / 2;
  cx.fillText(letter, centerx, centery);
}</pre>

Now we get a red letter on the Canvas and can paint over it:

<img src="" alt="painting on a letter">

<h2>How to ensure the user stays in the letter shape</h2> 






